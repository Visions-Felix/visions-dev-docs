{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Visions Developer Guide","text":"<p>This guide aims to provide comprehensive coding standards for the Visions development environment, best practices for React and TanStack development, as well as guidelines for testing and version control.</p> <p>The keywords MUST, SHOULD, MUST NOT, CAN used in this guide are to be respected thoroughly in order to maintain a scalable codebase.</p> <p>(WIP) currently only contains information regarding frontend development for React. But many of the elements in the conventions can be re-applied for backend development as well.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Coding Standards</li> <li>Guidelines for Testing</li> <li>Version Control Strategies</li> </ul> <p>Feel free to explore each section in detail and apply the knowledge to your development process.</p>"},{"location":"coding-standards/comments/","title":"Commenting Guide","text":"<p>Comments play a crucial role in making code more understandable and maintainable. They provide context and explanations for complex logic, helping current and future developers comprehend the codebase. This guide outlines best practices for adding comments to your code, with a focus on using JSDoc for documentation.</p>"},{"location":"coding-standards/comments/#general-principles","title":"General Principles","text":"<ol> <li>Use JSDoc: When possible, use JSDoc to provide structured documentation for your code.</li> <li>Be Descriptive: Ensure comments are clear and descriptive, explaining the \"why\" behind the code, not just the \"what.\"</li> <li>Keep Comments Updated: Always update comments to reflect any changes in the code.</li> <li>Don't Comment Just To Comment: Be smart about whether or not something needs commenting. Sometimes a good function, component or variable name is more than enough.</li> </ol>"},{"location":"coding-standards/comments/#comments-for-components","title":"Comments for Components","text":"<p>For React components, add comments especially when the component is complex or involves intricate logic.</p>"},{"location":"coding-standards/comments/#example","title":"Example","text":"<pre><code>/**\n * UserProfile component displays the user's profile information.\n *\n * @component\n * @example\n * const user = {\n *   name: 'John Doe',\n *   age: 30,\n *   email: 'john.doe@example.com'\n * }\n * return &lt;UserProfile user={user} /&gt;\n */\nconst UserProfile = ({ user }: { user: User }) =&gt; {\n  // Display user's profile information\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{user.name}&lt;/h1&gt;\n      &lt;p&gt;Age: {user.age}&lt;/p&gt;\n      &lt;p&gt;Email: {user.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Note: @example &amp; @component tags are optional but required when a component is of high complexity.</p>"},{"location":"coding-standards/comments/#comments-for-hooks","title":"Comments for Hooks","text":"<p>For custom hooks, document the props (if any) and the methods returned by the hook. Define a TypeScript type for the return value and use JSDoc to document the type.</p>"},{"location":"coding-standards/comments/#example_1","title":"Example","text":"<pre><code>/**\n * Return type for useAuth hook, containing the authentication state and methods.\n */\ntype UseAuthReturnType = {\n  /**\n   * Indicates if the user is authenticated.\n   */\n  isAuthenticated: boolean;\n\n  /**\n   * Function to log in the user.\n   *\n   * @param {User} userInfo - The user's information.\n   */\n  login: (userInfo: User) =&gt; void;\n\n  /**\n   * Function to log out the user.\n   */\n  logout: () =&gt; void;\n\n  /**\n   * The authenticated user's information.\n   */\n  user: User | null;\n};\n\n/**\n * useAuth is a custom hook that manages authentication state.\n *\n * @returns {UseAuthReturnType} The authentication state and methods.\n *\n * @example\n * const { isAuthenticated, login, logout, user } = useAuth();\n */\nconst useAuth = (): UseAuthReturnType =&gt; {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [user, setUser] = useState&lt;User | null&gt;(null);\n\n  const login = (userInfo: User) =&gt; {\n    setIsAuthenticated(true);\n    setUser(userInfo);\n  };\n\n  const logout = () =&gt; {\n    setIsAuthenticated(false);\n    setUser(null);\n  };\n\n  return { isAuthenticated, login, logout, user };\n};\n</code></pre>"},{"location":"coding-standards/comments/#comments-for-providers","title":"Comments for Providers","text":"<p>Context providers MUST be thoroughly documented on everything the context provides, the methods used within it. Comments detailing the functionality for complex logic MUST be included. </p> <p>A context provider MUST have a specific type detailing the context value and all attributes should be documented on the type for the users of the context to be able to have a reference documentation when accessing a value of the context.</p>"},{"location":"coding-standards/comments/#example_2","title":"Example","text":"<pre><code>/**\n * Context value type for AuthProvider, providing authentication state and methods.\n */\ntype AuthContextType = {\n  /**\n   * Indicates if the user is authenticated.\n   */\n  isAuthenticated: boolean;\n\n  /**\n   * Function to log in the user.\n   *\n   * @param {User} userInfo - The user's information.\n   */\n  login: (userInfo: User) =&gt; void;\n\n  /**\n   * Function to log out the user.\n   */\n  logout: () =&gt; void;\n\n  /**\n   * The authenticated user's information.\n   */\n  user: User | null;\n};\n\nconst AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);\n\n/**\n * AuthProvider component that provides authentication state and methods.\n *\n * @example\n * &lt;AuthProvider&gt;\n *   &lt;App /&gt;\n * &lt;/AuthProvider&gt;\n */\nconst AuthProvider = ({ children }: { children: React.ReactNode }): JSX.Element =&gt; {\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n  const [user, setUser] = useState&lt;User | null&gt;(null);\n\n  /**\n   * Logs in the user and updates the authentication state.\n   *\n   * @param {User} userInfo - The user's information.\n   */\n  const login = (userInfo: User) =&gt; {\n    setIsAuthenticated(true);\n    setUser(userInfo);\n  };\n\n  /**\n   * Logs out the user and clears the authentication state.\n   */\n  const logout = () =&gt; {\n    setIsAuthenticated(false);\n    setUser(null);\n  };\n\n  return (\n    &lt;AuthContext.Provider value={{ isAuthenticated, login, logout, user }}&gt;\n      {children}\n    &lt;/AuthContext.Provider&gt;\n  );\n};\n</code></pre>"},{"location":"coding-standards/comments/#complex-logic-example","title":"Complex Logic Example","text":"<pre><code>/**\n * Context value type for DataProvider, providing fetched data and loading state.\n */\ntype DataContextType = {\n  /**\n   * The fetched data.\n   */\n  data: any[];\n\n  /**\n   * Indicates if data is currently being loaded.\n   */\n  isLoading: boolean;\n};\n\nconst DataContext = createContext&lt;DataContextType | undefined&gt;(undefined);\n\ntype Props = {\n    /**\n     * Defines whether or not to activate this provider on page load (example definition)\n     */\n    active: string;\n}\n\n/**\n * DataProvider component that fetches and provides data to its children.\n *\n * @example\n * &lt;DataProvider&gt;\n *   &lt;App /&gt;\n * &lt;/DataProvider&gt;\n */\nconst DataProvider = (props: PropsWithChildren&lt;Props&gt;): JSX.Element =&gt; {\n  const [data, setData] = useState&lt;any[]&gt;([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    /**\n     * Fetches data from the API.\n     *\n     * @async\n     * @function fetchData\n     * @returns {Promise&lt;void&gt;}\n     */\n    const fetchData = async () =&gt; {\n      try {\n        const response = await fetch('/api/data');\n        const result = await response.json();\n        setData(result);\n        setIsLoading(false);\n      } catch (error) {\n        console.error('Failed to fetch data:', error);\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    &lt;DataContext.Provider value={{ data, isLoading }}&gt;\n      {children}\n    &lt;/DataContext.Provider&gt;\n  );\n};\n</code></pre>"},{"location":"coding-standards/comments/#summary","title":"Summary","text":"<ul> <li>Components: Add comments for complex components using JSDoc to document props and provide examples.</li> <li>Hooks: Use JSDoc to document the props, methods, and returned values of custom hooks. Define and document a TypeScript type for the return value.</li> <li>Providers: Thoroughly document everything the context provides, methods within the provider, and add comments for complex logic. Define and document a TypeScript type for the context value.</li> <li>Typing: As a general rule, type <code>any</code> SHOULD never be used as it makes maintaining the codebase much more difficult.</li> </ul>"},{"location":"coding-standards/file-structure/","title":"File Structure Guide","text":"<p>Maintaining a well-organized file structure is crucial for the scalability and maintainability of a project. Below is the guide to the file structure used in our project, detailing the purpose and conventions for each directory.</p>"},{"location":"coding-standards/file-structure/#root-directory-src","title":"Root Directory: <code>src/</code>","text":"<p>The <code>src/</code> directory is the root directory for all source code and assets of the project.</p>"},{"location":"coding-standards/file-structure/#api","title":"api/","text":"<p>The <code>api</code> directory contains everything that is needed to perform API operations with as much re-usability as possible.</p> <p>Since the project uses an APIClient that is required by our application in order to centralize API calls and centrally handle error scenarios, we need the API calls to be encapsulated in React hooks that would be used in children of an ClientProvider.</p> <p>The file structure for the <code>api</code> directory is organized by resource available on the API.</p> <p>We group hooks and utilitaries together instead of placing them directly in a separate hooks or utils directory to avoid having files that work on the same resource in different locations of the application.</p> <p>The following is an example for using the <code>projects</code> resource.</p>"},{"location":"coding-standards/file-structure/#useprojectsapitsx","title":"<code>useProjectsAPI.tsx</code>","text":"<p>The first file <code>useProjectsAPI.tsx</code> contains all of the API calls wrapped around the client provided by the ClientProvider. All API calls to the API concerning the projects resource should be centralized in this file.</p> <p>This enables any react component that is a child of the ClientProvider to use this api call.</p> <p>Note: In practice, we are currently using tanstack-query, so the APIs from this file are rarely used directly by components. Continue reading to understand why in the <code>useProjectsQuery.tsx</code> section.</p>"},{"location":"coding-standards/file-structure/#useprojectsquerytsx","title":"<code>useProjectsQuery.tsx</code>","text":"<p>This file is where all the tanstack-query queries are defined for the <code>projects</code> resource. It consumes the APIs provided by <code>useProjectsAPI.tsx</code> in order to use them as the queryFn of a useQuery.</p> <p>Visions's naming convention for variables and functions using tanstack need to end in \"Query\" or \"Mutation\" in order to be generally understood in the codebase and not misinterpreted as another function that is not tanstack based.</p> <p>If creating a tanstack query for fetching resources and there is a need to pass in variables, then the function name must end in \"QueryWrapper\" and must return the useQuery.</p> <p>Here are a couple of examples: |Query|What is does| | -- | -- | |projectsQuery|Returns the useQuery that uses the getProjects method from the useProjectsAPI hook| |projectQueryWrapper(id)|Returns the useQuery that uses the getProjectById(id) method from the useProjectsAPI hook</p> <p>Here are a couple more complex examples of what this could look like in code for another resource:</p> <pre><code>const serviceOfferingsQuery = useQuery({\n    queryKey: QUERY_KEYS.serviceOfferings,\n    queryFn: getServiceOfferings,\n    staleTime: QUERY_STALE_TIME.serviceOfferings,\n});\n\nconst serviceOfferingQueryWrapper = (id: string, { populated } = { populated: true }) =&gt; {\n    return useQuery({\n        queryKey: QUERY_KEYS.serviceOffering(id),\n        queryFn: () =&gt; getServiceOfferingById(id, { populated }),\n        staleTime: QUERY_STALE_TIME.serviceOfferings,\n        enabled: !!id,\n    });\n};\n</code></pre>"},{"location":"coding-standards/file-structure/#assets","title":"assets/","text":"<p>Contains static assets such as fonts, images, and videos.</p> <ul> <li>fonts/: Custom fonts used in the project.</li> <li>img/: Image files used throughout the application.</li> <li>videos/: Video files used in the application.</li> </ul>"},{"location":"coding-standards/file-structure/#components","title":"components/","text":"<p>Contains all React components organized by their atomic design principles.</p> <ul> <li>Atoms/: Basic, indivisible components (e.g., buttons, inputs).</li> <li>Molecules/: Compound components built from atoms (e.g., form groups, cards).</li> <li>Organisms/: Complex components built from atoms and molecules (e.g., headers, footers).</li> </ul>"},{"location":"coding-standards/file-structure/#constants","title":"constants/","text":"<p>Contains files that define shared constants used across the application. This could include things like API endpoints, configuration values, and other static values such as Tanstack Query constants for example.</p>"},{"location":"coding-standards/file-structure/#context","title":"context/","text":"<p>Contains context providers for React Context API, facilitating state management and sharing state across different parts of the application.</p>"},{"location":"coding-standards/file-structure/#data","title":"data/","text":"<p>Contains files that store fixed data not stored in a database. This could include static JSON data, mock data for development, or other non-dynamic data sources.</p>"},{"location":"coding-standards/file-structure/#hooks","title":"hooks/","text":"<p>Contains custom React hooks used in the application. These are reusable pieces of logic that encapsulate common behaviors and state management.</p>"},{"location":"coding-standards/file-structure/#layouts","title":"layouts/","text":"<p>Contains components used as layouts. These components define the structure of pages and can include headers, footers, and other layout elements.</p>"},{"location":"coding-standards/file-structure/#libs","title":"libs/","text":"<p>Contains modules and libraries on certain subjects. This could include third-party integrations, utility libraries, and other modular code that can be reused across the application.</p>"},{"location":"coding-standards/file-structure/#pages","title":"pages/","text":"<p>Contains components that represent a full page in the application. These are the top-level components that correspond to routes in the application.</p>"},{"location":"coding-standards/file-structure/#breaking-down-large-page-components","title":"Breaking down large page components","text":"<p>If a page component gets too large and complex, it is possible to break it down into smaller chunks.</p> <p>Each chunk (component) should be located in a \"components\" directory directly within that specific page directory if it is used only by this page.</p>"},{"location":"coding-standards/file-structure/#refactoring","title":"Refactoring","text":"<p>If a component in a <code>MyPage/components</code> directory looks like it could be used in another page / section in the application, it MUST be relocated in the general <code>components</code> folder.</p>"},{"location":"coding-standards/file-structure/#shared","title":"shared/","text":"<p>Contains shared content such as SCSS stylesheets, variables, mixins, and other styling resources that are used across multiple components.</p>"},{"location":"coding-standards/file-structure/#types","title":"types/","text":"<p>Contains custom TypeScript types used throughout the project. This helps in maintaining type safety and consistency.</p>"},{"location":"coding-standards/file-structure/#utils","title":"utils/","text":"<p>Contains utility function files. These are helper functions that perform common tasks and operations used across the application that are not directly React-related.</p>"},{"location":"coding-standards/file-structure/#example-file-structure","title":"Example File Structure","text":"<p>Here is an example of how the file structure might look in practice:</p> <pre><code>src/\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 resource/\n\u2502       \u2514\u2500\u2500 ResourceFormPayload.ts\n\u2502       \u2514\u2500\u2500 useResourceAPI.tsx\n\u2502       \u2514\u2500\u2500 useResourceQuery.tsx\n\u2502       \u2514\u2500\u2500 useResourceMutations.tsx\n\u251c\u2500\u2500 assets/\n\u2502   \u251c\u2500\u2500 fonts/\n\u2502   \u2502   \u2514\u2500\u2500 custom-font.woff\n\u2502   \u251c\u2500\u2500 img/\n\u2502   \u2502   \u2514\u2500\u2500 logo.png\n\u2502   \u2514\u2500\u2500 videos/\n\u2502       \u2514\u2500\u2500 intro.mp4\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Atoms/\n\u2502   \u2502   \u2514\u2500\u2500 Button.tsx\n\u2502   \u251c\u2500\u2500 Molecules/\n\u2502   \u2502   \u2514\u2500\u2500 Card.tsx\n\u2502   \u2514\u2500\u2500 Organisms/\n\u2502       \u2514\u2500\u2500 Header.tsx\n\u251c\u2500\u2500 constants/\n\u2502   \u2514\u2500\u2500 appBreakpoints.ts\n\u251c\u2500\u2500 context/\n\u2502   \u2514\u2500\u2500 AuthProvider.tsx\n\u251c\u2500\u2500 data/\n\u2502   \u2514\u2500\u2500 countries.json\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useAuth.ts\n\u251c\u2500\u2500 layouts/\n\u2502   \u2514\u2500\u2500 MainLayout.tsx\n\u251c\u2500\u2500 libs/\n\u2502   \u2514\u2500\u2500 analytics.ts\n\u251c\u2500\u2500 pages/\n\u2502   \u2514\u2500\u2500 HomePage\n\u2502       \u251c\u2500\u2500 HomePage.tsx\n\u2502       \u251c\u2500\u2500 HomePage.module.scss\n\u2502       \u2514\u2500\u2500 components/\n\u2502           \u2514\u2500\u2500 MyHomePageSpecificComponent.tsx\n\u251c\u2500\u2500 shared/\n\u2502   \u251c\u2500\u2500 styles/\n\u2502   \u2502   \u251c\u2500\u2500 variables.scss\n\u2502   \u2502   \u2514\u2500\u2500 mixins.scss\n\u251c\u2500\u2500 types/\n\u2502   \u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 formatDate.ts\n</code></pre>"},{"location":"coding-standards/file-structure/#best-practices","title":"Best Practices","text":"<ol> <li>Modularity: Keep components and modules small and focused. Each file should have a single responsibility.</li> <li>Reusability: Organize files to promote reuse. Shared components, hooks, and utilities should be easily accessible.</li> <li>Scalability: As the project grows, the file structure should accommodate new files and directories without major refactoring.</li> <li>Consistency: Follow consistent naming conventions and directory structures throughout the project.</li> </ol>"},{"location":"coding-standards/formatting/","title":"Formatting Guide","text":"<p>Consistent code formatting is crucial for maintaining readability and reducing the cognitive load on developers. This guide outlines the formatting standards for our project, which are enforced using Prettier.</p>"},{"location":"coding-standards/formatting/#prettier-configuration","title":"Prettier Configuration","text":"<p>Our project uses Prettier for code formatting. Prettier is an opinionated code formatter that ensures all code follows a consistent style. The configuration for Prettier is defined in the <code>.prettierrc</code> file at the root of the project.</p>"},{"location":"coding-standards/formatting/#formatting-before-committing","title":"Formatting Before Committing","text":"<p>Before committing your code, ensure that Prettier has been executed and all files are formatted. This step is crucial to maintain code consistency across the project.</p>"},{"location":"coding-standards/formatting/#use-regions-for-large-sections-of-code","title":"Use Regions for large sections of code","text":"<p>As in other programming languages, typescript can generally understand the regions defined in your code. These are defined like so:</p> <pre><code>//#region State Management\nconst [x, setX] = useState(0);\nconst [y, setY] = useState(1);\n//#endregion\n</code></pre> <p>This allows to separate and arrange blocks of code together in large files.</p> <p>Although this feature is generally a nice to have option, it must be used sparingly and not introduced in small files to not overload the file with unnecessary lines of code.</p>"},{"location":"coding-standards/formatting/#summary","title":"Summary","text":"<ul> <li>Follow Prettier Configuration: Ensure all code adheres to the formatting rules defined in the <code>.prettierrc</code> file.</li> <li>Run Prettier Before Committing: Always run Prettier to format your code before making a commit.</li> <li>Use Regions: Use regions to break out matching sections of your code in large project files.</li> </ul>"},{"location":"coding-standards/naming-conventions/","title":"General Coding Standards Guide","text":"<p>Adhering to consistent coding standards across a codebase ensures readability, maintainability, and collaboration efficiency. This guide outlines best practices for naming things, functions, files, and variables.</p>"},{"location":"coding-standards/naming-conventions/#naming-conventions","title":"Naming Conventions","text":""},{"location":"coding-standards/naming-conventions/#general-principles","title":"General Principles","text":"<ol> <li>Be Descriptive: Names should clearly describe what the item represents.</li> <li>Use Consistent Style: Follow a consistent style for naming similar items.</li> <li>Avoid Abbreviations: Use full words unless the abbreviation is well-known and widely accepted.</li> </ol>"},{"location":"coding-standards/naming-conventions/#variables","title":"Variables","text":"<ol> <li>Variables MUST use camelCase format:<ul> <li>Example: <code>userName</code>, <code>totalAmount</code></li> </ul> </li> <li>Boolean Variables SHOULD Start with 'is', 'has', or 'should':<ul> <li>Example: <code>isActive</code>, <code>hasPermission</code>, <code>shouldUpdate</code></li> </ul> </li> <li>Avoid Single-letter Variable Names:<ul> <li>Exception: Loop variables like <code>i</code>, <code>j</code>, <code>k</code></li> </ul> </li> </ol> <pre><code>let userName = 'JohnDoe';\nlet isUserActive = true;\n</code></pre>"},{"location":"coding-standards/naming-conventions/#functions","title":"Functions","text":"<ol> <li>Function Names MUST use camelCase format:<ul> <li>Example: <code>calculateTotal</code>, <code>fetchUserData</code></li> </ul> </li> <li>Function Names MUST start with a verb:<ul> <li>Example: <code>getUser</code>, <code>setName</code>, <code>isValid</code></li> </ul> </li> <li>Event handlers MUST use <code>handle</code> as a prefix:<ul> <li>Example: <code>handleClick</code>, <code>handleSubmit</code>, <code>handleChange</code></li> </ul> </li> <li>Avoid Long Function Names when possible: Keep them concise yet descriptive.</li> </ol> <p>Note on the usage of event callbacks such as onClick, etc.</p> <p><code>on[Action]</code> SHOULD only be used if set as a react component prop in order for the parent to not be confused in different naming compared to default HTML element browser event callback names (onClick, onChange...). The parent MUST provide a <code>handle[Action]</code> function as the prop value.</p> <pre><code>function calculateTotal(price, tax) {\n    return price + tax;\n}\n\nfunction fetchUserData(userId) {\n    // fetch data logic\n}\n\nfunction handleClick(event) {\n    // handle click event logic\n}\n</code></pre>"},{"location":"coding-standards/naming-conventions/#classes-and-interfaces","title":"Classes and Interfaces","text":"<ol> <li>Use PascalCase for Class and Interface Names:<ul> <li>Example: <code>UserManager</code>, <code>HttpClient</code></li> </ul> </li> <li>Use Nouns for Class Names: Class names should represent objects or concepts.<ul> <li>Example: <code>User</code>, <code>Invoice</code></li> </ul> </li> <li>Prefix Interfaces with 'I':<ul> <li>Example: <code>IUser</code>, <code>IInvoice</code></li> </ul> </li> </ol> <pre><code>class UserManager {\n    constructor() {\n        // initialization logic\n    }\n}\n\ninterface IUser {\n    id: number;\n    name: string;\n}\n</code></pre>"},{"location":"coding-standards/naming-conventions/#constants","title":"Constants","text":"<ol> <li>Use UPPER_CASE for variables that are understood ad Constants:<ul> <li>Example: <code>MAX_RETRIES</code>, <code>DEFAULT_TIMEOUT</code></li> </ul> </li> <li>Separate Words with Underscores:<ul> <li>Example: <code>API_BASE_URL</code></li> </ul> </li> </ol> <p>Note: This does not mean all variables declared with <code>const</code> should be uppercase. Only those who are accepted as \"configuration\" constants.</p> <pre><code>const MAX_RETRIES = 5;\nconst API_BASE_URL = 'https://api.example.com';\n</code></pre>"},{"location":"coding-standards/naming-conventions/#files","title":"Files","text":"<ol> <li> <p>React Component Files: Use PascalCase format for file names.</p> <ul> <li>Example: <code>UserProfile.tsx</code>, <code>InvoiceDetails.tsx</code></li> </ul> </li> <li> <p>SCSS Module Files: Use PascalCase format, matching the corresponding React component name with <code>.module.scss</code> suffix.</p> <ul> <li>Example: <code>UserProfile.module.scss</code>, <code>InvoiceDetails.module.scss</code></li> </ul> </li> <li> <p>Other Scripts: Use camelCase format for file names.</p> <ul> <li>Example: <code>myUtilsFile.ts</code></li> </ul> </li> </ol> <pre><code># Correct\nUserProfile.tsx\nUserProfile.module.scss\ninvoiceDetails.tsx\ninvoiceDetails.module.scss\nuserService.ts\nauthMiddleware.ts\n\n# Incorrect\nuser-profile.tsx\nuser-profile.module.scss\ninvoice-details.tsx\ninvoice-details.module.scss\nUserService.ts\nAuthMiddleware.ts\n</code></pre>"},{"location":"coding-standards/naming-conventions/#naming-conventions-for-specific-scenarios","title":"Naming Conventions for Specific Scenarios","text":"<ol> <li>Event Handlers: Use 'handle' as a prefix for the function names responding to events.<ul> <li>Example: <code>handleClick</code>, <code>handleUserLogin</code></li> </ul> </li> <li>Props Passing Event Handlers: Use 'on' as a prefix.<ul> <li>Example: <code>onClick</code>, <code>onUserLogin</code></li> </ul> </li> <li>Test Files: Mirror the file name of the tested module and suffix with <code>.test</code>.<ul> <li>Example: <code>user-manager.test.ts</code></li> </ul> </li> </ol>"},{"location":"coding-standards/naming-conventions/#best-practices","title":"Best Practices","text":"<ol> <li>Consistency Over Preference: The established conventions MUST be followed even if personal preferences differ.</li> <li>Refactor for Clarity: Functions, classes &amp; variables MUST be renamed if a new naming becomes apparent.</li> <li>Review and Enforce Standards: Regularly review code and ensure adherence to naming conventions.</li> </ol>"},{"location":"coding-standards/react/context/","title":"Using Context &amp; Providers","text":"<p>Context and providers are powerful tools in React that allow you to share data and functionality across components without passing props manually. In the context of the VisionsTrust app, understanding how to properly use context and providers is crucial for building scalable and maintainable code.</p>"},{"location":"coding-standards/react/context/#what-is-context","title":"What is Context?","text":"<p>Context in React provides a way to pass data through the component tree without having to pass props down manually at every level. It allows you to share data between components that are not directly connected in the component hierarchy.</p>"},{"location":"coding-standards/react/context/#creating-a-context-provider","title":"Creating a Context &amp; Provider","text":"<p>To create a context in the VisionsTrust app, you can use the <code>createContext</code> function from the <code>react</code> package.</p> <p>A provider is a component that allows consuming components to subscribe to the context changes. It provides the context value to all its descendants. In the VisionsTrust app, you can create a provider component to wrap the relevant parts of the component tree.</p> <p>Here's an example for a Theme Context Provider. It sets the type of the context value, creates the type, creates the provider and assigns the value of the correct type to the Provider.</p> <p>For simplicity of the example, comments were removed, but all context providers MUST have their documentation. Please refer to the comments section which details this about providers. </p> <pre><code>// File: ThemeProvider.tsx\n\nimport { createContext, PropsWithChildren, useContext, useState } from 'react';\n\ninterface ThemeContextValue {\n    theme: string;\n    handleThemeChange: (theme: string) =&gt; void;\n}\n\nconst ThemeContext = createContext&lt;ThemeContextValue&gt;({} as ThemeContextValue);\n\nexport const ThemeProvider = ({ children }: PropsWithChildren) =&gt; {\n    const [theme, setTheme] = useState('light');\n\n    const handleThemeChange = (newTheme: string) =&gt; {\n        setTheme(newTheme);\n    };\n\n    return &lt;ThemeContext.Provider value={{ theme, handleThemeChange }}&gt;{children}&lt;/ThemeContext.Provider&gt;;\n};\n</code></pre>"},{"location":"coding-standards/react/context/#consuming-the-context","title":"Consuming the Context","text":"<p>To consume the context in a component, the <code>useContext()</code> hook MUST be encapsulated in a custom hook with the name of the provider.</p> <p>The context consumption should always check if it is called from within the bounds of his Provider, thus the custom hook should verify or throw an Error if not in order to catch the issues as soon as possible during development.</p> <p>Here's an example from our theme provider.</p> <pre><code>// File: ThemeProvider.tsx\n\nexport const useTheme = () =&gt; {\n    const context = useContext(ThemeContext);\n\n    if (!context) throw new Error('useTheme should be used within a ThemeProvider');\n\n    return context;\n};\n</code></pre> <p>Once the hook exists in the code, any component can consume the context by calling the hook.</p> <pre><code>const MyComponent = () =&gt; {\n    const { theme, handleThemeChange } = useTheme();\n\n    return (\n        &lt;div&gt;\n            &lt;button onClick={() =&gt; handleThemeChange('dark')}&gt;Change Theme&lt;/button&gt;\n            &lt;p&gt;Current Theme: {theme}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"coding-standards/react/context/#using-the-provider","title":"Using the Provider","text":"<p>To use the provider in the VisionsTrust app, you need to wrap the relevant parts of the component tree with the provider component created earlier. Here's an example:</p> <pre><code>const App = () =&gt; {\n    return &lt;ThemeProvider&gt;{/* Component tree */}&lt;/ThemeProvider&gt;;\n};\n</code></pre>"},{"location":"coding-standards/react/context/#documenting-complex-methods","title":"Documenting Complex Methods","text":"<p>This section is an extension of the comments section.</p> <p>When working with complex methods in a provider, it is important to provide clear and concise documentation. This helps other developers understand the purpose, inputs, and outputs of the method, making it easier to maintain and debug the codebase.</p> <p>Here are some best practices for documenting complex methods in a provider:</p> <ol> <li> <p>Use descriptive function names: Choose function names that accurately describe what the method does. Avoid generic names that can be ambiguous or misleading.</p> </li> <li> <p>Add comments: Include comments within the method to explain the logic and any important details. This can help other developers understand the implementation and make modifications if needed.</p> </li> <li> <p>Document parameters and return values: Clearly specify the parameters that the method expects and the type of value it returns. This helps other developers understand how to use the method correctly and what to expect as a result.</p> </li> <li> <p>Provide examples: (If necessary) Include examples of how to use the method in different scenarios. This can help other developers understand the intended usage and provide guidance on how to handle edge cases.</p> </li> <li> <p>Update documentation as needed: If methods or attributes change, the documentation MUST reflect these changes.</p> </li> </ol>"},{"location":"coding-standards/react/context/#avoid-over-complexifying-providers","title":"Avoid Over-Complexifying Providers","text":"<p>While providers are powerful tools for sharing data and functionality, it is important to avoid over-complexifying them. A provider should have a clear and specific purpose, focusing on a single responsibility. This helps maintain a clean and maintainable codebase.</p> <p>Here are some tips to avoid over-complexifying a provider:</p> <ol> <li> <p>Single responsibility principle: Ensure that the provider is responsible for a specific set of data or functionality. Avoid adding unrelated features or functionalities that can make the provider bloated and harder to understand.</p> </li> <li> <p>Modularize functionality: If the provider becomes too large or complex, consider breaking it down into smaller, more manageable pieces. This can improve code organization and make it easier to maintain and test.</p> </li> <li> <p>Separate concerns: Keep the provider focused on managing state and providing data or functionality. Avoid mixing business logic or UI-related code within the provider. Instead, delegate those responsibilities to separate modules or components.</p> </li> <li> <p>Use composition: Instead of adding more complexity to a single provider, consider using composition to combine multiple providers with specific responsibilities. This can help maintain a clear separation of concerns and make the codebase more modular.</p> </li> </ol> <p>By following these practices, you can ensure that your provider remains focused, maintainable, and easy to understand, while effectively sharing data and functionality across components.</p>"},{"location":"coding-standards/react/context/#summary","title":"Summary","text":"<p>In the VisionsTrust app, context and providers are essential for sharing data and functionality across components. By creating a context, defining a provider, and consuming the context using the <code>useContext</code> hook, you can effectively manage and share state and methods throughout your app.</p> <p>Remember to use context and providers judiciously, as excessive use can lead to a complex and hard-to-maintain codebase. Use them when it makes sense to share data or functionality across multiple components that are not directly connected in the component hierarchy.</p>"},{"location":"coding-standards/react/general/","title":"General React Development Guidelines","text":""},{"location":"coding-standards/react/general/#user-experience","title":"User Experience","text":"<p>The experience of the people using the application should come first.</p> <p>As a react developer, it is a MUST to put yourself in a user's shoes and ask yourself if the experience is good or not.</p>"},{"location":"coding-standards/react/general/#action-feedback","title":"Action Feedback","text":"<p>All of a user's interaction with the application should have some sort of feedback indicating the results of the interaction to the user.</p> <p>If, as a user, I do not know what happened or what I am doing, the application is at fault.</p>"},{"location":"coding-standards/react/general/#form-error-handling","title":"Form Error Handling","text":"<p>Errors, especially in forms, MUST be reflected directly in the form in order for the user to know exactly what is missing or invalid.</p>"},{"location":"coding-standards/react/hooks/","title":"Using Hooks","text":"<p>Hooks are a powerful feature in React that allow you to use state and other React features without writing a class. In the context of the VisionsTrust app, understanding how to properly use hooks is crucial for avoiding un-necessary complexity in components.</p>"},{"location":"coding-standards/react/hooks/#what-are-hooks","title":"What are Hooks?","text":"<p>Hooks are functions that let you \"hook into\" React state and lifecycle features from function components. They provide a way to use stateful logic and other React functionalities in function components.</p>"},{"location":"coding-standards/react/hooks/#custom-hooks","title":"Custom Hooks","text":"<p>Custom hooks are a mechanism to reuse stateful logic between components. They are a great way to extract and share logic that involves hooks.</p>"},{"location":"coding-standards/react/hooks/#creating-a-custom-hook","title":"Creating a Custom Hook","text":"<p>Here's an example of a custom hook that uses a certain query from TanStack Query.</p> <pre><code>\n/**\n * Use this hook in any component to make the page scroll\n * to the top as soon as this component is rendered when the\n * location changes.\n */\nexport const useScrollTop = () =&gt; {\n    const location = useLocation();\n    useEffect(() =&gt; {\n        window.scrollTo(0, 0);\n    }, [location]);\n};\n</code></pre>"},{"location":"coding-standards/react/hooks/#using-a-custom-hook","title":"Using a Custom Hook","text":"<p>You can use the custom hook in any component just like built-in hooks.</p> <pre><code>import useScrollTop from './useScrollTop';\n\nconst MyComponent = () =&gt; {\n    useScrollTop();\n\n    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\n\n    return &lt;div&gt;Data: {data}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"coding-standards/react/hooks/#best-practices-for-using-hooks","title":"Best Practices for Using Hooks","text":"<ol> <li> <p>Keep hooks at the top level: Hooks MUST be called at the top-level of components and MUST NOT be called conditionnaly or in loops.</p> </li> <li> <p>Custom hook naming convention: Custom hooks MUST start with the <code>use</code> keyword.</p> </li> <li> <p>Avoid overusing hooks: Custom hooks SHOULD be used only when necessary to remove complexity in components and allow for reusable logic.</p> </li> <li> <p>Encapsulate logic: Custom hooks MUST encapsulate re-usable logic in order to make the application more modular.</p> </li> <li> <p>Dependency arrays: When using <code>useEffect</code>, <code>useMemo</code>, or <code>useCallback</code>, always specify dependencies correctly to avoid unexpected behaviors or performance issues.</p> </li> </ol>"},{"location":"coding-standards/tanstack/mutations/","title":"Tanstack Query: Handling Mutations","text":"<p>This section details the conventions for mutatioins for Visions react projects using Tanstack-Query.</p>"},{"location":"coding-standards/tanstack/mutations/#conventions","title":"Conventions","text":"<p>Please refer to the naming-convention for the more general aspects of the convention.</p> <p>As a general rule, all mutations are a combination of a function (that MUST start with a verb) and a mutation.</p> <p>In order to recognize these in the codebase, all mutations MUST end with the keyword <code>Mutation</code>.</p> <pre><code>const createDataRepresentationMutation = useMutation({\n    mutationFn: async ({ payload }: { payload: DataRepresentationsFormPayloadType }) =&gt; {\n        return await createDataRepresentation(payload);\n    },\n    onError: async (error) =&gt; {\n        console.error(error);\n    },\n    onSuccess: async (_, variables) =&gt; {\n        invalidateDataResourceQuery(variables?.payload.resourceID);\n    },\n});\n</code></pre>"},{"location":"coding-standards/tanstack/mutations/#query-invalidation","title":"Query Invalidation","text":"<p>Developers MUST spend time thinking about the impact of a mutation on the rest of the queries in the application.</p> <p>The following questions must be asked in order to determine which queries should be invalidated after a mutation.</p> <p>This is a very important step as it defines how everything will react to a user's actions within the application.</p> <ul> <li>What does this mutation change in the database ? (user experience)</li> <li>What information should I be able to see as a user of the application as a result of this mutation ? (user experience)</li> <li>Do I need to invalidate this query ? (performance)</li> </ul>"},{"location":"coding-standards/tanstack/queries/","title":"Tanstack Query: Queries","text":"<p>This section details the conventions for Visions react projects using Tanstack-Query.</p>"},{"location":"coding-standards/tanstack/queries/#query-keys","title":"Query Keys","text":"<p>Query keys MUST exist in a specific <code>query.constants.ts</code> or <code>queries.constants.ts</code> file.</p> <p>Each new element in a url should be a key passed to the queryKey array. Query params should be set in an object. A couple of examples:</p> url queryKey /posts [\"posts\"] /posts/{id} [\"posts\", id] /posts?foo=bar [\"posts\", {foo: bar}] /posts?page=1&amp;limit=10 [\"posts\", {page: 1, limit: 10}] /posts/{id}/comments [\"posts\", id, \"comments\"] /posts/{id}/comments?authorId={authorId} [\"posts\", id, \"comments\", {authorId: authorId}]"},{"location":"coding-standards/tanstack/queries/#stale-time","title":"Stale Time","text":"<p>Query stale time keys MUST exist in the same constants file as defined in the query keys section.</p> <p>Each query stale time key value should be thought of extensively as this can drastically impact the application in terms of functionality and performance.</p>"},{"location":"coding-standards/tanstack/queries/#guidelines","title":"Guidelines","text":""},{"location":"coding-standards/tanstack/queries/#long-stale-time","title":"Long Stale Time","text":"<ul> <li>Queries that fetch data that never or rarely changes</li> </ul>"},{"location":"coding-standards/tanstack/queries/#short-stale-time","title":"Short Stale Time","text":"<ul> <li>Queries that fetch data that is very dynamic or sensible</li> <li>Queries that fetch data that updates at regular intervals</li> </ul>"},{"location":"coding-standards/tanstack/queries/#custom-stale-time","title":"Custom Stale Time","text":"<p>Each query's stale time should be thought of independently as the application can have specific requirements.</p> <p>As a general rule, the objective is to make the application as performant as possible but it MUST not disable any functionality for the sake of performance.</p>"},{"location":"version-control/branch-naming/","title":"Branch Naming Guide","text":"<p>Consistent and descriptive branch naming conventions help streamline collaboration and make it easier to understand the purpose and scope of each branch at a glance. Follow these conventions to maintain a clean and organized Git repository.</p>"},{"location":"version-control/branch-naming/#general-conventions","title":"General Conventions","text":"<ol> <li> <p>Use Lowercase and Hyphen-Separated Names:</p> <ul> <li>Stick to lowercase letters and use hyphens (<code>-</code>) to separate words.</li> <li>Avoid using underscores (<code>_</code>), camel case, or any non-alphanumeric character.</li> </ul> </li> <li> <p>Include a Prefix for Context:</p> <ul> <li>Prefixes help to quickly identify the purpose of a branch.</li> </ul> </li> </ol>"},{"location":"version-control/branch-naming/#prefix-categories","title":"Prefix Categories","text":""},{"location":"version-control/branch-naming/#feature-branches","title":"Feature Branches","text":"<p>Use for new features or enhancements.</p> <p>Format: <code>feature/brief-description</code></p> <p>Examples:</p> <ul> <li><code>feature/add-user-authentication</code></li> <li><code>feature/update-dashboard-ui</code></li> </ul>"},{"location":"version-control/branch-naming/#bug-fix-branches","title":"Bug Fix Branches","text":"<p>Use for bug fixes.</p> <p>Format: <code>bugfix/brief-description</code></p> <p>Examples:</p> <ul> <li><code>bugfix/fix-login-issue</code></li> <li><code>bugfix/correct-header-styling</code></li> </ul>"},{"location":"version-control/branch-naming/#hotfix-branches","title":"Hotfix Branches","text":"<p>Use for urgent fixes in the production environment.</p> <p>Format: <code>hotfix/brief-description</code></p> <p>Examples:</p> <ul> <li><code>hotfix/patch-security-vulnerability</code></li> <li><code>hotfix/resolve-payment-error</code></li> </ul>"},{"location":"version-control/branch-naming/#release-branches","title":"Release Branches","text":"<p>Use for preparing a new production release.</p> <p>Format: <code>release/version-number</code></p> <p>Examples:</p> <ul> <li><code>release/1.2.0</code></li> <li><code>release/2.0.1</code></li> </ul>"},{"location":"version-control/branch-naming/#chore-branches","title":"Chore Branches","text":"<p>Use for routine tasks and maintenance that do not affect the product's functionality (e.g., updating dependencies, refactoring code).</p> <p>Format: <code>chore/brief-description</code></p> <p>Examples:</p> <ul> <li><code>chore/update-dependencies</code></li> <li><code>chore/refactor-user-service</code></li> </ul>"},{"location":"version-control/branch-naming/#documentation-branches","title":"Documentation Branches","text":"<p>Use for documentation updates and changes.</p> <p>Format: <code>docs/brief-description</code></p> <p>Examples:</p> <ul> <li><code>docs/update-readme</code></li> <li><code>docs/add-api-documentation</code></li> </ul>"},{"location":"version-control/branch-naming/#examples-and-best-practices","title":"Examples and Best Practices","text":"<ol> <li>Be Descriptive but Concise:<ul> <li>Clearly describe the branch's purpose in a few words.</li> <li>Avoid overly long names.</li> </ul> </li> <li>Use Consistent Tense and Style:<ul> <li>Maintain a uniform style throughout the branch names.</li> <li>Typically use imperative mood (e.g., <code>add</code>, <code>fix</code>, <code>update</code>).</li> </ul> </li> <li>Avoid Using Personal Names:<ul> <li>Do not include personal names or identifiers in branch names.</li> </ul> </li> </ol>"},{"location":"version-control/branch-naming/#example-workflow","title":"Example Workflow","text":"<ol> <li>Creating a New Feature:<ul> <li>Branch name: <code>feature/add-comment-section</code></li> </ul> </li> <li>Fixing a Bug:<ul> <li>Branch name: <code>bugfix/fix-404-error</code></li> </ul> </li> <li>Making an Urgent Fix:<ul> <li>Branch name: <code>hotfix/repair-crash-on-login</code></li> </ul> </li> <li>Preparing for a Release:<ul> <li>Branch name: <code>release/1.3.0</code></li> </ul> </li> <li>Updating Documentation:<ul> <li>Branch name: <code>docs/add-setup-guide</code></li> </ul> </li> </ol>"},{"location":"version-control/conventional-commits/","title":"Conventional Commits Guide","text":"<p>Using Conventional Commits provides a standard way to structure commit messages, making it easier to read and understand the history of changes in a project. This guide outlines the rules for writing commit messages according to the Conventional Commits specification.</p>"},{"location":"version-control/conventional-commits/#commit-message-format","title":"Commit Message Format","text":"<p>A commit message consists of a header, optional body, and optional footer. The header is mandatory and must conform to the format below:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"version-control/conventional-commits/#header","title":"Header","text":"<p>The header is mandatory and includes:</p> <ul> <li>type: A keyword indicating the type of change (see below for types).</li> <li>optional scope: A noun describing a section of the codebase enclosed in parentheses, e.g., <code>(parser)</code>, <code>(login)</code>. This is optional.</li> <li>description: A brief description of the change in present tense, not capitalized, and no period at the end.</li> </ul>"},{"location":"version-control/conventional-commits/#body","title":"Body","text":"<p>The body is optional and should include additional information about the commit. Use it to explain the motivation for the change and contrast it with previous behavior.</p>"},{"location":"version-control/conventional-commits/#footer","title":"Footer","text":"<p>The footer is optional and can include information about breaking changes and issues that the commit closes. Breaking changes must start with <code>BREAKING CHANGE:</code> followed by an explanation.</p>"},{"location":"version-control/conventional-commits/#types","title":"Types","text":""},{"location":"version-control/conventional-commits/#commonly-used-types","title":"Commonly Used Types","text":"<ul> <li>feat: A new feature.</li> <li>fix: A bug fix.</li> <li>docs: Documentation-only changes.</li> <li>style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc).</li> <li>refactor: A code change that neither fixes a bug nor adds a feature.</li> <li>perf: A code change that improves performance.</li> <li>test: Adding missing or correcting existing tests.</li> <li>build: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm).</li> <li>ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs).</li> <li>chore: Other changes that don't modify src or test files.</li> <li>revert: Reverts a previous commit.</li> </ul>"},{"location":"version-control/conventional-commits/#examples","title":"Examples","text":""},{"location":"version-control/conventional-commits/#feature-commit","title":"Feature Commit","text":"<pre><code>feat(parser): add ability to parse arrays\n\nAdd support for parsing arrays. This change introduces a new method\nto the parser module that allows it to handle arrays in input data.\n</code></pre>"},{"location":"version-control/conventional-commits/#bug-fix-commit","title":"Bug Fix Commit","text":"<pre><code>fix(login): resolve login issue on iOS devices\n\nFixed a bug that caused the login process to fail on iOS devices due\nto incorrect handling of touch events.\n</code></pre>"},{"location":"version-control/conventional-commits/#documentation-commit","title":"Documentation Commit","text":"<pre><code>docs: update API usage section in README\n\nClarified the usage of the API with examples and detailed parameter descriptions.\n</code></pre>"},{"location":"version-control/conventional-commits/#breaking-change-commit","title":"Breaking Change Commit","text":"<pre><code>feat(auth): update authentication method\n\nBREAKING CHANGE: The authentication method has been updated to use JWT tokens\ninstead of session-based authentication. This requires all clients to update\ntheir authentication logic.\n</code></pre>"},{"location":"version-control/conventional-commits/#commit-closing-an-issue","title":"Commit Closing an Issue","text":"<pre><code>fix(router): handle unknown routes properly\n\nEnsure that unknown routes return a 404 status code and render the NotFound component.\n\nCloses #123.\n</code></pre>"},{"location":"version-control/conventional-commits/#best-practices","title":"Best Practices","text":"<ol> <li>Be Consistent: Always follow the Conventional Commits format to ensure a consistent and understandable commit history.</li> <li>Use the Right Type: Choose the appropriate type for your commit to clearly convey the nature of the change.</li> <li>Write Clear Descriptions: Make your descriptions concise yet informative. Use the body to provide additional context if needed.</li> <li>Reference Issues: When applicable, reference issues in the footer to provide traceability.</li> </ol>"},{"location":"version-control/pull-requests/","title":"Pull Request Guide","text":"<p>Pull requests (PRs) are essential for code review, ensuring code quality, and facilitating collaboration among team members. This guide outlines the best practices and process for creating, submitting, and reviewing pull requests.</p>"},{"location":"version-control/pull-requests/#creating-a-pull-request","title":"Creating a Pull Request","text":""},{"location":"version-control/pull-requests/#1-branching","title":"1. Branching","text":"<p>Before starting work on a new feature or bug fix, create a new branch from the <code>dev</code> branch. Follow the branch naming conventions.</p>"},{"location":"version-control/pull-requests/#2-commit-messages","title":"2. Commit Messages","text":"<p>Ensure your commit messages follow the Conventional Commits format. This provides a clear and understandable history of changes.</p>"},{"location":"version-control/pull-requests/#3-write-clear-and-concise-description","title":"3. Write Clear and Concise Description","text":"<p>When creating a pull request, provide a clear and concise description. Include the following:</p> <ul> <li>What: A brief summary of what the PR does.</li> <li>Why: The reason for the change, including any relevant context.</li> <li>How: A brief description of how the changes were made.</li> <li>Testing: (if applicable) Details of how the changes were tested.</li> </ul>"},{"location":"version-control/pull-requests/#4-reference-issues","title":"4. Reference Issues","text":"<p>If your pull request addresses or closes an issue, reference it in the description. This provides traceability and context for reviewers.</p> <pre><code>Closes #123\n</code></pre>"},{"location":"version-control/pull-requests/#5-request-reviewers","title":"5. Request Reviewers","text":"<p>Assign relevant team members as reviewers who have the expertise or context to review the changes effectively.</p>"},{"location":"version-control/pull-requests/#6-include-screenshotslogs","title":"6. Include Screenshots/Logs","text":"<p>If applicable, include screenshots or logs to provide additional context, especially for UI changes or bugs that are visually identifiable.</p>"},{"location":"version-control/pull-requests/#submitting-a-pull-request","title":"Submitting a Pull Request","text":""},{"location":"version-control/pull-requests/#1-ensure-code-completeness","title":"1. Ensure Code Completeness","text":"<p>Before submitting a PR, ensure that your code is complete, functional, and meets the project's requirements. Do not submit PRs with unfinished code.</p>"},{"location":"version-control/pull-requests/#2-run-tests","title":"2. Run Tests","text":"<p>Run all relevant tests locally to ensure that your changes do not introduce any new issues. Include new tests if your changes introduce new functionality or fix bugs.</p>"},{"location":"version-control/pull-requests/#3-linting-and-formatting","title":"3. Linting and Formatting","text":"<p>Ensure that your code follows the project's coding standards and style guidelines. Run any linters or formatters to clean up your code.</p>"},{"location":"version-control/pull-requests/#reviewing-a-pull-request","title":"Reviewing a Pull Request","text":""},{"location":"version-control/pull-requests/#1-understand-the-context","title":"1. Understand the Context","text":"<p>Before reviewing, understand the context of the changes by reading the description, related issues, and any linked documentation.</p>"},{"location":"version-control/pull-requests/#2-review-code-thoroughly","title":"2. Review Code Thoroughly","text":"<ul> <li>Correctness: Verify that the code functions as expected and does not introduce bugs.</li> <li>Readability: Ensure the code is readable and follows the project's style guidelines.</li> <li>Design: Assess the design and structure of the code for maintainability and scalability.</li> <li>Testing: Check that adequate tests are included and that they pass.</li> </ul>"},{"location":"version-control/pull-requests/#3-provide-constructive-feedback","title":"3. Provide Constructive Feedback","text":"<ul> <li>Be Specific: Point out specific lines or sections of code with suggestions for improvements.</li> <li>Be Respectful: Provide feedback respectfully and constructively.</li> <li>Ask Questions: If something is unclear, ask questions to understand the changes better.</li> </ul>"},{"location":"version-control/pull-requests/#4-approve-or-request-changes","title":"4. Approve or Request Changes","text":"<p>After reviewing, either approve the PR or request changes. If requesting changes, provide clear instructions on what needs to be addressed.</p>"},{"location":"version-control/pull-requests/#5-re-review-if-necessary","title":"5. Re-Review if Necessary","text":"<p>If changes are made after your review, re-review the updated code to ensure that all issues have been addressed.</p>"},{"location":"version-control/pull-requests/#merging-a-pull-request","title":"Merging a Pull Request","text":""},{"location":"version-control/pull-requests/#1-verify-approvals","title":"1. Verify Approvals","text":"<p>Ensure that the PR has received the necessary approvals from the required reviewers.</p>"},{"location":"version-control/pull-requests/#2-resolve-conflicts","title":"2. Resolve Conflicts","text":"<p>If there are merge conflicts, resolve them before merging the PR. Ensure that the resolved code is still functional and passes all tests.</p>"},{"location":"version-control/pull-requests/#3-squash-commits","title":"3. Squash Commits","text":"<p>If applicable, squash commits to clean up the commit history. This is particularly useful for PRs with many small commits.</p>"},{"location":"version-control/pull-requests/#4-merge-strategy","title":"4. Merge Strategy","text":"<p>Use the appropriate merge strategy (merge, squash, rebase) based on the project's guidelines.</p>"},{"location":"version-control/pull-requests/#5-post-merge-actions","title":"5. Post-Merge Actions","text":"<ul> <li>Close Related Issues: Ensure that any related issues are closed.</li> <li>Notify Stakeholders: Notify relevant team members or stakeholders about the merged changes if necessary.</li> </ul>"},{"location":"version-control/version-management/","title":"Version Management Guide","text":"<p>Version management is crucial for maintaining a clear and organized development process, ensuring that changes are tracked accurately and that releases are well-documented. This guide outlines best practices for updating software versions, including when and how to update versions, and the process to follow.</p>"},{"location":"version-control/version-management/#semantic-versioning","title":"Semantic Versioning","text":"<p>We follow Semantic Versioning (SemVer) for our versioning strategy. Semantic Versioning uses a three-part version number: <code>MAJOR.MINOR.PATCH</code>.</p> <ul> <li>MAJOR version when you make incompatible API changes.</li> <li>MINOR version when you add functionality in a backwards-compatible manner.</li> <li>PATCH version when you make backwards-compatible bug fixes.</li> </ul>"},{"location":"version-control/version-management/#when-to-update-the-version","title":"When to Update the Version","text":""},{"location":"version-control/version-management/#major-version-major","title":"Major Version (MAJOR)","text":"<p>Update the major version when there are significant changes that break backward compatibility. Examples include:</p> <ul> <li>Removing or renaming public APIs.</li> <li>Significant changes in functionality that require users to modify their code to accommodate the changes.</li> </ul>"},{"location":"version-control/version-management/#minor-version-minor","title":"Minor Version (MINOR)","text":"<p>Update the minor version when new features are added in a backward-compatible manner. Examples include:</p> <ul> <li>Adding new functionalities that do not break existing APIs.</li> <li>Deprecating existing features without removing them.</li> </ul>"},{"location":"version-control/version-management/#patch-version-patch","title":"Patch Version (PATCH)","text":"<p>Update the patch version for backward-compatible bug fixes. Examples include:</p> <ul> <li>Fixing bugs.</li> <li>Minor performance improvements.</li> </ul>"},{"location":"version-control/version-management/#version-update-process","title":"Version Update Process","text":""},{"location":"version-control/version-management/#feature-branches","title":"Feature Branches","text":"<ol> <li>Do Not Update Version Numbers:<ul> <li>Version numbers should not be updated directly within feature branches. This avoids conflicts and ensures a smooth integration process.</li> </ul> </li> </ol>"},{"location":"version-control/version-management/#pull-requests","title":"Pull Requests","text":"<ol> <li>Do Not Update Version Numbers in PRs:<ul> <li>When submitting a pull request, do not include version number updates. Focus on implementing and testing the feature or fix.</li> <li>Exception: The models github package require this in order to perform a package publication when merged in main</li> </ul> </li> </ol>"},{"location":"version-control/version-management/#after-merging","title":"After Merging","text":"<ol> <li>Update the Version Number:<ul> <li>After merging a pull request into the <code>main</code> branch, the version number should be updated as part of the release process.</li> </ul> </li> </ol>"},{"location":"version-control/version-management/#release-process","title":"Release Process","text":"<ol> <li> <p>Determine the Version Increment:</p> <ul> <li>Decide whether the changes require a major, minor, or patch version increment based on the guidelines above.</li> </ul> </li> <li> <p>Update the Version Number:</p> <ul> <li>Update the version number in the appropriate configuration files (package.json).</li> <li>Ensure the version number follows the SemVer format.</li> </ul> </li> <li> <p>Commit the Version Update:</p> <ul> <li>Create a commit with a message that clearly indicates the version update. Example:     <code>chore: bump version to 1.2.0</code></li> </ul> </li> <li> <p>Tag the Commit:</p> <ul> <li>If applicable, Tag the commit with the new version number. Example:     <code>git tag -a v1.2.0 -m \"Release version 1.2.0\"</code></li> </ul> </li> <li> <p>Push the Tag:</p> <ul> <li>If applicable, Push the commit and tag to the repository.     <code>git push origin main --tags</code></li> </ul> </li> <li> <p>Create a Release:</p> <ul> <li>If applicable, create a release in the repository and include release notes that summarize the changes.</li> </ul> </li> </ol>"},{"location":"version-control/version-management/#best-practices-wip-auto-generated","title":"Best Practices (WIP, auto-generated)","text":"<ol> <li>Automate Versioning:<ul> <li>Use tools or scripts to automate the versioning process where possible. This reduces the risk of human error and ensures consistency.</li> </ul> </li> <li>Consistent Release Notes:<ul> <li>Maintain consistent and clear release notes that provide a summary of changes, including new features, bug fixes, and any breaking changes.</li> </ul> </li> <li>Communicate Changes:<ul> <li>Ensure that all stakeholders are aware of the version changes, especially for major versions that may require changes on their part.</li> </ul> </li> <li>Testing Before Release:<ul> <li>Thoroughly test the software before updating the version and creating a release. This includes automated tests, manual tests, and any other relevant testing processes.</li> </ul> </li> <li>Continuous Integration:<ul> <li>Integrate version management into the CI/CD pipeline to ensure that version updates are part of the deployment process.</li> </ul> </li> </ol>"}]}